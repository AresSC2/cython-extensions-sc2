{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Cython Extensions SC2","text":""},{"location":"index.html#cython_extensions.combat_utils.cy_adjust_moving_formation","title":"<code>cy_adjust_moving_formation(our_units, target, fodder_tags, unit_multiplier, retreat_angle)</code>","text":"<p>Adjust units formation.</p> <p>Big thanks to idontcodethisgame for the original code in Eris</p> <p>The idea here is that we give UnitTypeId's a fodder value, and this cython function works out which unit we want at the front to absorb damage. This works by returning a dictionary containing tags of the non fodder units that need to move backwards behind the fodder and the position they should move to.</p> <p>TIP: Don't use this when combat is already active, will probably lead to anti-micro. Use this while moving across the map and pre combat.</p> <p>Example: <pre><code>import numpy as np\nfrom cython_extensions import cy_find_aoe_position, cy_find_units_center_mass\nfrom sc2.ids.ability_id import AbilityId\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.units import Units\nfrom sc2.unit import Unit\n\ndef detect_fodder_value(self, units) -&gt; int:\n\n    # zealot will always be fodder\n    # if no zealot this will pick the next best unit type\n    # stalker will never be fodder in this example\n    unit_fodder_values: dict[UnitTypeId, int] = {\n            UnitTypeId.STALKER: 4,\n            UnitTypeId.ZEALOT: 1,\n            UnitTypeId.ADEPT: 2,\n            UnitTypeId.PROBE: 3,\n    }\n\n    # establish how many fodder levels there are\n    unit_type_fodder_values: set[int] = {\n        unit_fodder_values[u.type_id]\n        for u in units\n        if u.type_id in unit_fodder_values\n    }\n\n    # if there's only one fodder level, no units are fodder\n    if len(unit_type_fodder_values) &gt; 1:\n        return min(unit_type_fodder_values)\n    else:\n        return 0\n\nasync def on_step(self, iteration: int):\n    if not self.enemy_units:\n        return\n    # find lowest fodder value among our units\n    # will return 0 if our army only has one fodder level\n    fodder_value: int = self.detect_fodder_value(self.units)\n\n    fodder_tags = []\n    units_that_need_to_move = dict()\n\n    # there are fodder levels, calculate unit adjustment\n    if fodder_value &gt; 0:\n        for unit in self.units:\n            if (\n                unit.type_id in self.unit_fodder_values\n                and self.unit_fodder_values[unit.type_id] == fodder_value\n            ):\n                fodder_tags.append(unit.tag)\n\n        units_that_need_to_move = cy_adjust_moving_formation(\n            self.units,\n            cy_find_units_center_mass(self.enemy_units, 5.0)[0],\n            fodder_tags,\n            1.0,\n            0.25,\n        )\n\n    for unit in self.units:\n        if (\n            unit.tag in units_that_need_to_move\n            and unit.distance_to(self.enemy_units.center) &gt; 9.0\n        ):\n            # in practise check this position is valid (pathable, in bounds etc)\n            # left out here for example clarity\n            unit.move(Point2(units_that_need_to_move[unit.tag]))\n        else:\n            unit.attack(self.enemy_units.center)\n</code></pre></p> <p>324 \u00b5s \u00b1 9.44 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)</p> <p>Parameters:</p> Name Type Description Default <code>our_units</code> <code>Union[Units, list[Unit]]</code> <p>All our squad units, including core and fodder.</p> required <code>target</code> <code>Union[Point2, tuple[float, float]]</code> <p>The target we want the fodder to lead us to.</p> required <code>fodder_tags</code> <code>list[int]</code> <p>A list of fodder unit tags.</p> required <code>unit_multiplier</code> <code>float</code> <p>How far core units should retreat when adjusting during combat.</p> required <code>retreat_angle</code> <code>float</code> <p>Angle (in radians) for diagonal retreat of core units.</p> required <p>Returns:</p> Type Description <code>dict[int, tuple[float, float]]</code> <p>A dictionary where keys are unit tags requiring movement</p> <code>dict[int, tuple[float, float]]</code> <p>and values are tuples of x, y coordinates.</p> Source code in <code>cython_extensions/combat_utils.pyi</code> <pre><code>def cy_adjust_moving_formation(\n    our_units: Union[Units, list[Unit]],\n    target: Union[Point2, tuple[float, float]],\n    fodder_tags: list[int],\n    unit_multiplier: float,\n    retreat_angle: float,\n) -&gt; dict[int, tuple[float, float]]:\n    \"\"\"Adjust units formation.\n\n    Big thanks to idontcodethisgame for the original code in Eris\n\n    The idea here is that we give UnitTypeId's a fodder value,\n    and this cython function works out which unit we want at\n    the front to absorb damage. This works by returning a dictionary\n    containing tags of the non fodder units that need to move backwards\n    behind the fodder and the position they should move to.\n\n    TIP: Don't use this when combat is already active, will\n    probably lead to anti-micro. Use this while moving across the\n    map and pre combat.\n\n    Example:\n    ```py\n    import numpy as np\n    from cython_extensions import cy_find_aoe_position, cy_find_units_center_mass\n    from sc2.ids.ability_id import AbilityId\n    from sc2.ids.unit_typeid import UnitTypeId\n    from sc2.position import Point2\n    from sc2.units import Units\n    from sc2.unit import Unit\n\n    def detect_fodder_value(self, units) -&gt; int:\n\n        # zealot will always be fodder\n        # if no zealot this will pick the next best unit type\n        # stalker will never be fodder in this example\n        unit_fodder_values: dict[UnitTypeId, int] = {\n                UnitTypeId.STALKER: 4,\n                UnitTypeId.ZEALOT: 1,\n                UnitTypeId.ADEPT: 2,\n                UnitTypeId.PROBE: 3,\n        }\n\n        # establish how many fodder levels there are\n        unit_type_fodder_values: set[int] = {\n            unit_fodder_values[u.type_id]\n            for u in units\n            if u.type_id in unit_fodder_values\n        }\n\n        # if there's only one fodder level, no units are fodder\n        if len(unit_type_fodder_values) &gt; 1:\n            return min(unit_type_fodder_values)\n        else:\n            return 0\n\n    async def on_step(self, iteration: int):\n        if not self.enemy_units:\n            return\n        # find lowest fodder value among our units\n        # will return 0 if our army only has one fodder level\n        fodder_value: int = self.detect_fodder_value(self.units)\n\n        fodder_tags = []\n        units_that_need_to_move = dict()\n\n        # there are fodder levels, calculate unit adjustment\n        if fodder_value &gt; 0:\n            for unit in self.units:\n                if (\n                    unit.type_id in self.unit_fodder_values\n                    and self.unit_fodder_values[unit.type_id] == fodder_value\n                ):\n                    fodder_tags.append(unit.tag)\n\n            units_that_need_to_move = cy_adjust_moving_formation(\n                self.units,\n                cy_find_units_center_mass(self.enemy_units, 5.0)[0],\n                fodder_tags,\n                1.0,\n                0.25,\n            )\n\n        for unit in self.units:\n            if (\n                unit.tag in units_that_need_to_move\n                and unit.distance_to(self.enemy_units.center) &gt; 9.0\n            ):\n                # in practise check this position is valid (pathable, in bounds etc)\n                # left out here for example clarity\n                unit.move(Point2(units_that_need_to_move[unit.tag]))\n            else:\n                unit.attack(self.enemy_units.center)\n    ```\n\n    324 \u00b5s \u00b1 9.44 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n\n    Args:\n        our_units: All our squad units, including core and fodder.\n        target: The target we want the fodder to lead us to.\n        fodder_tags: A list of fodder unit tags.\n        unit_multiplier: How far core units should retreat when\n            adjusting during combat.\n        retreat_angle: Angle (in radians) for diagonal\n            retreat of core units.\n\n    Returns:\n        A dictionary where keys are unit tags requiring movement\n        and values are tuples of x, y coordinates.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.combat_utils.cy_attack_ready","title":"<code>cy_attack_ready(ai, unit, target)</code>","text":"<p>Check if the unit is ready to attack the target.</p> <p>Takes into account turn rate and unit speeds</p> <p>Example: <pre><code>from cython_extensions import cy_attack_ready\n\nworker = self.workers[0]\ntarget = self.enemy_units[0]\n\nattack_ready: bool = cy_attack_ready(self, worker, target)\n</code></pre></p> <pre><code>1.46 \u00b5s \u00b1 5.45 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nPython alternative:\n5.66 \u00b5s \u00b1 21.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>ai</code> <code>BotAI</code> <p>Bot object that will be running the game.</p> required <code>unit</code> <code>Unit</code> <p>The unit we want to check.</p> required <code>target</code> <code>Unit</code> <p>The thing we want to shoot.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the unit is ready to attack the target, False otherwise.</p> Source code in <code>cython_extensions/combat_utils.pyi</code> <pre><code>def cy_attack_ready(ai: BotAI, unit: Unit, target: Unit) -&gt; bool:\n    \"\"\"Check if the unit is ready to attack the target.\n\n    Takes into account turn rate and unit speeds\n\n    Example:\n    ```py\n    from cython_extensions import cy_attack_ready\n\n    worker = self.workers[0]\n    target = self.enemy_units[0]\n\n    attack_ready: bool = cy_attack_ready(self, worker, target)\n    ```\n\n    ```\n    1.46 \u00b5s \u00b1 5.45 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    Python alternative:\n    5.66 \u00b5s \u00b1 21.2 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n    ```\n\n    Args:\n        ai: Bot object that will be running the game.\n        unit: The unit we want to check.\n        target: The thing we want to shoot.\n\n    Returns:\n        True if the unit is ready to attack the target, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.combat_utils.cy_find_aoe_position","title":"<code>cy_find_aoe_position(effect_radius, targets, bonus_tags=None)</code>","text":"<p>Find best splash target given a group of enemies.</p> <p>Big thanks to idontcodethisgame for the original code in Eris</p> <p>WARNING: Please don't spam this function, it's fine to use as required but is costly. For example: only use this if unit ability is ready, only if enemy are in combat range etc.</p> <p>Example: <pre><code>import numpy as np\nfrom cython_extensions import cy_find_aoe_position\nfrom sc2.ids.ability_id import AbilityId\nfrom sc2.ids.unit_typeid import UnitTypeId\nfrom sc2.position import Point2\nfrom sc2.units import Units\nfrom sc2.unit import Unit\n\nenemies: Units = self.enemy_units\n\nfor unit in self.units:\n    if unit.type_id == UnitTypeId.RAVAGER:\n        # in practice, don't do this query for every individual unit\n        abilities = await self.get_available_abilities(unit)\n        if AbilityId.EFFECT_CORROSIVEBILE in abilities:\n            target: Optional[np.ndarray] = cy_find_aoe_position(effect_radius=1.375, targets=enemies)\n            # in practise in some scenarios, you should do an extra check to\n            # count how many units you would hit, this only finds position, not amount\n            if pos is not None:\n                unit(AbilityId.EFFECT_CORROSIVEBILE, Point2(pos))\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>effect_radius</code> <code>float</code> <p>The radius of the effect (range).</p> required <code>targets</code> <code>Union[Units, list[Unit]]</code> <p>All enemy units we would like to check.</p> required <code>bonus_tags</code> <code>set[int]</code> <p>If provided, give more value to these enemy tags.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[ndarray]</code> <p>A 1D numpy array containing x and y coordinates of aoe position,</p> <code>Optional[ndarray]</code> <p>or None.</p> Source code in <code>cython_extensions/combat_utils.pyi</code> <pre><code>def cy_find_aoe_position(\n    effect_radius: float, targets: Union[Units, list[Unit]], bonus_tags: set[int] = None\n) -&gt; Optional[np.ndarray]:\n    \"\"\"Find best splash target given a group of enemies.\n\n    Big thanks to idontcodethisgame for the original code in Eris\n\n    WARNING: Please don't spam this function, it's fine to use as required\n    but is costly. For example: only use this if unit ability is ready,\n    only if enemy are in combat range etc.\n\n    Example:\n    ```py\n    import numpy as np\n    from cython_extensions import cy_find_aoe_position\n    from sc2.ids.ability_id import AbilityId\n    from sc2.ids.unit_typeid import UnitTypeId\n    from sc2.position import Point2\n    from sc2.units import Units\n    from sc2.unit import Unit\n\n    enemies: Units = self.enemy_units\n\n    for unit in self.units:\n        if unit.type_id == UnitTypeId.RAVAGER:\n            # in practice, don't do this query for every individual unit\n            abilities = await self.get_available_abilities(unit)\n            if AbilityId.EFFECT_CORROSIVEBILE in abilities:\n                target: Optional[np.ndarray] = cy_find_aoe_position(effect_radius=1.375, targets=enemies)\n                # in practise in some scenarios, you should do an extra check to\n                # count how many units you would hit, this only finds position, not amount\n                if pos is not None:\n                    unit(AbilityId.EFFECT_CORROSIVEBILE, Point2(pos))\n    ```\n\n    Args:\n        effect_radius: The radius of the effect (range).\n        targets: All enemy units we would like to check.\n        bonus_tags: If provided, give more value to these enemy tags.\n\n    Returns:\n        A 1D numpy array containing x and y coordinates of aoe position,\n        or None.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.combat_utils.cy_is_facing","title":"<code>cy_is_facing(unit, other_unit, angle_error)</code>","text":"<p>Get turn speed of unit in radians</p> <p>Example: <pre><code>from cython_extensions import cy_is_facing\n\nunit: Unit = self.workers[0]\nother_unit: Unit = self.townhalls[0]\nis_facing: bool = cy_is_facing(unit, other_unit)\n</code></pre> <pre><code>323 ns \u00b1 3.93 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nPython-sc2's `unit.is_facing(other_unit)` alternative:\n2.94 \u00b5s \u00b1 8 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit</code> <p>The actual unit we are checking.</p> required <code>other_unit</code> <code>int</code> <p>The unit type ID integer value.</p> required <code>angle_error</code> <code>float</code> <p>Some leeway when deciding if a unit is facing the other unit.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the unit is facing the other unit, False otherwise.</p> Source code in <code>cython_extensions/combat_utils.pyi</code> <pre><code>def cy_is_facing(unit: Unit, other_unit: int, angle_error: float) -&gt; bool:\n    \"\"\"Get turn speed of unit in radians\n\n    Example:\n    ```py\n    from cython_extensions import cy_is_facing\n\n    unit: Unit = self.workers[0]\n    other_unit: Unit = self.townhalls[0]\n    is_facing: bool = cy_is_facing(unit, other_unit)\n    ```\n    ```\n    323 ns \u00b1 3.93 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    Python-sc2's `unit.is_facing(other_unit)` alternative:\n    2.94 \u00b5s \u00b1 8 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n    ```\n\n    Args:\n        unit: The actual unit we are checking.\n        other_unit: The unit type ID integer value.\n        angle_error: Some leeway when deciding if a unit is facing the other unit.\n        Defaults to 0.3.\n\n    Returns:\n        True if the unit is facing the other unit, False otherwise.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.combat_utils.cy_pick_enemy_target","title":"<code>cy_pick_enemy_target(enemies)</code>","text":"<p>Pick the best thing to shoot at out of all enemies.</p> <p>Example: <pre><code>from cython_extensions import cy_pick_enemy_target\nfrom sc2.units import Units\nfrom sc2.unit import Unit\n\nenemies: Units = self.enemy_units\n\ntarget: Unit = cy_pick_enemy_target(enemies)\n</code></pre> <pre><code>70.5 \u00b5s \u00b1 818 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\nPython alternative:\n115 \u00b5s \u00b1 766 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>enemies</code> <code>Union[Units, list[Unit]]</code> <p>All enemy units we would like to check.</p> required <p>Returns:</p> Type Description <code>Unit</code> <p>The best unit to target.</p> Source code in <code>cython_extensions/combat_utils.pyi</code> <pre><code>def cy_pick_enemy_target(enemies: Union[Units, list[Unit]]) -&gt; Unit:\n    \"\"\"Pick the best thing to shoot at out of all enemies.\n\n    Example:\n    ```py\n    from cython_extensions import cy_pick_enemy_target\n    from sc2.units import Units\n    from sc2.unit import Unit\n\n    enemies: Units = self.enemy_units\n\n    target: Unit = cy_pick_enemy_target(enemies)\n    ```\n    ```\n    70.5 \u00b5s \u00b1 818 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n    Python alternative:\n    115 \u00b5s \u00b1 766 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n    ```\n\n    Args:\n        enemies: All enemy units we would like to check.\n\n    Returns:\n        The best unit to target.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.combat_utils.cy_range_vs_target","title":"<code>cy_range_vs_target(unit, target)</code>","text":"<p>Cython version of range_vs_target</p> <p>Example: <pre><code>from cython_extensions import cy_range_vs_target\nfrom sc2.unit import Unit\n\nunit: Unit = self.units[0]\ntarget: Unit = self.enemies[0]\n\nrange: float = cy_range_vs_target(unit, target)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit</code> <p>The unit we want to check.</p> required <code>target</code> <code>Unit</code> <p>The target we want to check.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The weapon range to the target</p> Source code in <code>cython_extensions/combat_utils.pyi</code> <pre><code>def cy_range_vs_target(unit: Unit, target: Unit) -&gt; float:\n    \"\"\"Cython version of range_vs_target\n\n    Example:\n    ```py\n    from cython_extensions import cy_range_vs_target\n    from sc2.unit import Unit\n\n    unit: Unit = self.units[0]\n    target: Unit = self.enemies[0]\n\n    range: float = cy_range_vs_target(unit, target)\n    ```\n\n    Args:\n        unit: The unit we want to check.\n        target: The target we want to check.\n\n    Returns:\n        The weapon range to the target\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.dijkstra.DijkstraOutput","title":"<code>DijkstraOutput</code>","text":"<p>Result of Dijkstras algorithm containing distance and forward pointer grids.</p> <p>Attributes:</p> Name Type Description <code>forward_x</code> <code>ndarray</code> <p>Forward pointer grid (x-coordinates).</p> <code>forward_y</code> <code>ndarray</code> <p>Forward pointer grid (y-coordinates).</p> <code>distance</code> <code>ndarray</code> <p>Distance grid.</p> Source code in <code>cython_extensions/dijkstra.pyi</code> <pre><code>class DijkstraOutput:\n    \"\"\"Result of Dijkstras algorithm containing distance and forward pointer grids.\n\n    Attributes:\n        forward_x: Forward pointer grid (x-coordinates).\n        forward_y: Forward pointer grid (y-coordinates).\n        distance: Distance grid.\n\n    \"\"\"\n\n    forward_x: np.ndarray\n    forward_y: np.ndarray\n    distance: np.ndarray\n\n    def get_path(\n        self, source: tuple[int, int], limit: int = 0\n    ) -&gt; list[tuple[int, int]]:\n        \"\"\"Follow the path from a given source using the forward pointer grids.\n\n        Args:\n            source: Start point.\n            limit: Maximum length of the returned path. Defaults to 0 indicating no limit.\n\n        Returns:\n            The lowest cost path from source to any of the targets.\n\n        \"\"\"\n        ...\n</code></pre>"},{"location":"index.html#cython_extensions.dijkstra.DijkstraOutput.get_path","title":"<code>get_path(source, limit=0)</code>","text":"<p>Follow the path from a given source using the forward pointer grids.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>tuple[int, int]</code> <p>Start point.</p> required <code>limit</code> <code>int</code> <p>Maximum length of the returned path. Defaults to 0 indicating no limit.</p> <code>0</code> <p>Returns:</p> Type Description <code>list[tuple[int, int]]</code> <p>The lowest cost path from source to any of the targets.</p> Source code in <code>cython_extensions/dijkstra.pyi</code> <pre><code>def get_path(\n    self, source: tuple[int, int], limit: int = 0\n) -&gt; list[tuple[int, int]]:\n    \"\"\"Follow the path from a given source using the forward pointer grids.\n\n    Args:\n        source: Start point.\n        limit: Maximum length of the returned path. Defaults to 0 indicating no limit.\n\n    Returns:\n        The lowest cost path from source to any of the targets.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.dijkstra.cy_dijkstra","title":"<code>cy_dijkstra(cost_grid, targets, checks_enabled=True)</code>","text":"<p>Run Dijkstras algorithm on a grid, yielding many-target-shortest paths for each position.</p> <p>Example: <pre><code>from cython_extensions import cy_dijkstra\n\ntargets = np.array([u.position.rounded for u in bot.enemy_units], np.intp)\ncost = np.where(bot.game_info.pathing_grid.data_numpy.T == 1, 1.0, np.inf).astype(np.float64)\npathing = cy_dijkstra(cost, targets)\n\nfor unit in bot.units:\n    path = pathing.get_path(unit.position.rounded, limit=7)  # path limit is optional\n    unit.move(Point2(path[-1]))\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>cost_grid</code> <code>ndarray</code> <p>Cost grid. Entries must be positive. Set unpathable cells to infinity.</p> required <code>targets</code> <code>ndarray</code> <p>Target array of shape (*, 2) containing x and y coordinates of the target points.</p> required <code>checks_enabled</code> <code>bool</code> <p>Pass False to deactivate grid value and target coordinates checks. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DijkstraOutput</code> <p>Pathfinding object containing distances and pointer grids.</p> Source code in <code>cython_extensions/dijkstra.pyi</code> <pre><code>def cy_dijkstra(\n    cost_grid: np.ndarray, targets: np.ndarray, checks_enabled: bool = True\n) -&gt; DijkstraOutput:\n    \"\"\"Run Dijkstras algorithm on a grid, yielding many-target-shortest paths for each position.\n\n    Example:\n    ```py\n    from cython_extensions import cy_dijkstra\n\n    targets = np.array([u.position.rounded for u in bot.enemy_units], np.intp)\n    cost = np.where(bot.game_info.pathing_grid.data_numpy.T == 1, 1.0, np.inf).astype(np.float64)\n    pathing = cy_dijkstra(cost, targets)\n\n    for unit in bot.units:\n        path = pathing.get_path(unit.position.rounded, limit=7)  # path limit is optional\n        unit.move(Point2(path[-1]))\n    ```\n\n    Args:\n        cost_grid: Cost grid. Entries must be positive. Set unpathable cells to infinity.\n        targets: Target array of shape (*, 2) containing x and y coordinates of the target points.\n        checks_enabled: Pass False to deactivate grid value and target coordinates checks. Defaults to True.\n\n    Returns:\n        Pathfinding object containing distances and pointer grids.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.general_utils.cy_has_creep","title":"<code>cy_has_creep(creep_numpy_grid, position)</code>","text":"<p>Check if a position has creep.</p> <p>Example: <pre><code>from cython_functions import cy_has_creep\nfrom sc2.position import Point2\n\nposition: Point2 = self.start_location\n\nhas_creep: bool = cy_has_creep(\n    self.state.creep.data_numpy,\n    position\n)\n</code></pre></p> <pre><code>243 ns \u00b1 4.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>creep_numpy_grid</code> <code>ndarray</code> <p>Position to check for power.</p> required <code>position</code> <code>Point2</code> <p>The pylons we want to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>position</code> has creep, False otherwise.</p> Source code in <code>cython_extensions/general_utils.pyi</code> <pre><code>def cy_has_creep(creep_numpy_grid: np.ndarray, position: Point2) -&gt; bool:\n    \"\"\"\n    Check if a position has creep.\n\n    Example:\n    ```py\n    from cython_functions import cy_has_creep\n    from sc2.position import Point2\n\n    position: Point2 = self.start_location\n\n    has_creep: bool = cy_has_creep(\n        self.state.creep.data_numpy,\n        position\n    )\n    ```\n\n    ```\n    243 ns \u00b1 4.4 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n    ```\n\n    Args:\n        creep_numpy_grid: Position to check for power.\n        position: The pylons we want to check.\n\n\n    Returns:\n        True if `position` has creep, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.general_utils.cy_in_pathing_grid_burny","title":"<code>cy_in_pathing_grid_burny(pathing_numpy_grid, position)</code>","text":"<p>Check if a position is pathable. This is optimized for use with the numpy pathing grid found in burnysc2. <code>self.game_info.pathing_grid.data_numpy</code> which only contains 0s and 1s.</p> <p>This is a fast replacement for <code>self.in_pathing_grid(position)</code> function in burnysc2.</p> <p>If using MapAnalyzer grids or some other type of numpy grid, check out <code>cy_in_pathing_grid_ma</code> instead/</p> <p>Example using burny sc2: <pre><code>from cython_functions import cy_in_pathing_grid_burny\nfrom sc2.position import Point2\n\nposition: Point2 = self.start_location\n\nis_pathable: bool = cy_in_pathing_grid_burny(\n    self.game_info.pathing_grid.data_numpy,\n    position\n)\n</code></pre></p> <pre><code>243 ns \u00b1 1.51 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pathing_numpy_grid</code> <code>ndarray</code> <p>The 2D grid to check on.</p> required <code>position</code> <code>Point2</code> <p>The postions we want to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>position</code> is pathable, False otherwise.</p> Source code in <code>cython_extensions/general_utils.pyi</code> <pre><code>def cy_in_pathing_grid_burny(pathing_numpy_grid: np.ndarray, position: Point2) -&gt; bool:\n    \"\"\"\n    Check if a position is pathable. This is optimized for use with\n    the numpy pathing grid found in burnysc2.\n    `self.game_info.pathing_grid.data_numpy` which only contains\n    0s and 1s.\n\n    This is a fast replacement for `self.in_pathing_grid(position)` function\n    in burnysc2.\n\n    If using MapAnalyzer grids or some other type of numpy grid,\n    check out `cy_in_pathing_grid_ma` instead/\n\n    Example using burny sc2:\n    ```py\n    from cython_functions import cy_in_pathing_grid_burny\n    from sc2.position import Point2\n\n    position: Point2 = self.start_location\n\n    is_pathable: bool = cy_in_pathing_grid_burny(\n        self.game_info.pathing_grid.data_numpy,\n        position\n    )\n    ```\n\n    ```\n    243 ns \u00b1 1.51 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n    ```\n\n    Args:\n        pathing_numpy_grid: The 2D grid to check on.\n        position: The postions we want to check.\n\n\n    Returns:\n        True if `position` is pathable, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.general_utils.cy_in_pathing_grid_ma","title":"<code>cy_in_pathing_grid_ma(pathing_numpy_grid, position)</code>","text":"<p>Check if a position is pathable. This is optimized for use with numpy pathing grids from MapAnalyzer that contain enemy influence. The grids passed in here are already transposed vs the burnysc2 default pathing grid. This may work with other custom numpy pathing grids that contain float values.</p> <p>Example using ares sc2 (which has MapAnalyzer grids): <pre><code>from cython_functions import cy_in_pathing_grid_ma\nfrom sc2.position import Point2\n\nposition: Point2 = self.start_location\n# ares function to get pathing grid containing enemy influence\ngrid: np.ndarray = self.mediator.get_ground_grid\n\nis_pathable: bool = cy_in_pathing_grid_ma(\n    grid, position\n)\n</code></pre></p> <pre><code>243 ns \u00b1 1.51 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>pathing_numpy_grid</code> <code>ndarray</code> <p>The 2D grid to check on.</p> required <code>position</code> <code>Point2</code> <p>The postions we want to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>position</code> is pathable, False otherwise.</p> Source code in <code>cython_extensions/general_utils.pyi</code> <pre><code>def cy_in_pathing_grid_ma(pathing_numpy_grid: np.ndarray, position: Point2) -&gt; bool:\n    \"\"\"\n    Check if a position is pathable. This is optimized for use with\n    numpy pathing grids from MapAnalyzer that contain enemy influence.\n    The grids passed in here are already transposed vs the burnysc2\n    default pathing grid.\n    This may work with other custom numpy pathing grids that contain float values.\n\n    Example using ares sc2 (which has MapAnalyzer grids):\n    ```py\n    from cython_functions import cy_in_pathing_grid_ma\n    from sc2.position import Point2\n\n    position: Point2 = self.start_location\n    # ares function to get pathing grid containing enemy influence\n    grid: np.ndarray = self.mediator.get_ground_grid\n\n    is_pathable: bool = cy_in_pathing_grid_ma(\n        grid, position\n    )\n    ```\n\n    ```\n    243 ns \u00b1 1.51 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n    ```\n\n    Args:\n        pathing_numpy_grid: The 2D grid to check on.\n        position: The postions we want to check.\n\n\n    Returns:\n        True if `position` is pathable, False otherwise.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.general_utils.cy_pylon_matrix_covers","title":"<code>cy_pylon_matrix_covers(position, pylons, height_grid, pylon_build_progress=1.0)</code>","text":"<p>Check if a position is powered by a pylon.</p> <p>Example: <pre><code>from cython_functions import cy_pylon_matrix_covers\nfrom sc2.position import Point2\n\n# check if start location is powered by pylon\nposition: Point2 = self.start_location\n\ncan_place_structure_here: bool = cy_pylon_matrix_covers(\n    position,\n    self.structures(UnitTypeId.PYLON),\n    self.game_info.terrain_height.data_numpy\n)\n</code></pre></p> <pre><code>1.85 \u00b5s \u00b1 8.72 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Union[Point2, tuple[float, float]]</code> <p>Position to check for power.</p> required <code>pylons</code> <code>Union[Units, list[Unit]]</code> <p>The pylons we want to check.</p> required <code>height_grid</code> <code>ndarray</code> <p>Height grid supplied from <code>python-sc2</code> as a numpy array.</p> required <code>pylon_build_progress</code> <code>Optional[float]</code> <p>If less than 1.0, check near pending pylons. Default is 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>position</code> has power, False otherwise.</p> Source code in <code>cython_extensions/general_utils.pyi</code> <pre><code>def cy_pylon_matrix_covers(\n    position: Union[Point2, tuple[float, float]],\n    pylons: Union[Units, list[Unit]],\n    height_grid: np.ndarray,\n    pylon_build_progress: Optional[float] = 1.0,\n) -&gt; bool:\n    \"\"\"Check if a position is powered by a pylon.\n\n    Example:\n    ```py\n    from cython_functions import cy_pylon_matrix_covers\n    from sc2.position import Point2\n\n    # check if start location is powered by pylon\n    position: Point2 = self.start_location\n\n    can_place_structure_here: bool = cy_pylon_matrix_covers(\n        position,\n        self.structures(UnitTypeId.PYLON),\n        self.game_info.terrain_height.data_numpy\n    )\n    ```\n\n    ```\n    1.85 \u00b5s \u00b1 8.72 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n    ```\n\n    Args:\n        position: Position to check for power.\n        pylons: The pylons we want to check.\n        height_grid: Height grid supplied from `python-sc2` as a numpy array.\n        pylon_build_progress: If less than 1.0, check near pending pylons.\n            Default is 1.0.\n\n    Returns:\n        True if `position` has power, False otherwise.\n\n    \"\"\"\n</code></pre>"},{"location":"index.html#cython_extensions.general_utils.cy_unit_pending","title":"<code>cy_unit_pending(ai, unit_type)</code>","text":"<p>Check how many unit_type are pending.</p> <p>Faster unit specific alternative to <code>python-sc2</code>'s <code>already_pending</code></p> <p>Example: <pre><code>from cython_functions import cy_unit_pending\nfrom sc2.ids.unit_typeid import UnitTypeId\n\nnum_marines_pending: int = cy_unit_pending(UnitTypeId.MARINE)\n</code></pre> <pre><code>453 ns \u00b1 9.35 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nPython-sc2 `already_pending` alternative:\n2.82 \u00b5s \u00b1 29 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>ai</code> <code>BotAI</code> <p>Bot object that will be running the game.</p> required <code>unit_type</code> <code>UnitTypeId</code> <p>Unit type we want to check.</p> required <p>Returns:</p> Type Description <code>int</code> <p>How many unit_type are currently building.</p> Source code in <code>cython_extensions/general_utils.pyi</code> <pre><code>def cy_unit_pending(ai: \"BotAI\", unit_type: UnitID) -&gt; int:\n    \"\"\"Check how many unit_type are pending.\n\n    Faster unit specific alternative to `python-sc2`'s `already_pending`\n\n    Example:\n    ```py\n    from cython_functions import cy_unit_pending\n    from sc2.ids.unit_typeid import UnitTypeId\n\n    num_marines_pending: int = cy_unit_pending(UnitTypeId.MARINE)\n    ```\n    ```\n    453 ns \u00b1 9.35 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    Python-sc2 `already_pending` alternative:\n    2.82 \u00b5s \u00b1 29 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n    ```\n\n    Args:\n        ai: Bot object that will be running the game.\n        unit_type: Unit type we want to check.\n\n    Returns:\n        How many unit_type are currently building.\n\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_angle_diff","title":"<code>cy_angle_diff(a, b)</code>","text":"<p>Absolute angle difference between 2 angles</p> <p>Parameters:</p> Name Type Description Default <code>a</code> <code>float</code> <p>First angle.</p> required <code>b</code> <code>float</code> <p>Second angle.</p> required <p>Returns:</p> Name Type Description <code>angle_difference</code> <code>float</code> <p>Difference between the two angles.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_angle_diff(a: float, b: float) -&gt; float:\n    \"\"\"Absolute angle difference between 2 angles\n\n    Args:\n        a: First angle.\n        b: Second angle.\n\n    Returns:\n        angle_difference: Difference between the two angles.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_angle_to","title":"<code>cy_angle_to(from_pos, to_pos)</code>","text":"<p>Angle from point to other point in radians</p> <p>Parameters:</p> Name Type Description Default <code>from_pos</code> <code>Union[Point2, tuple[float, float]]</code> <p>First 2D point.</p> required <code>to_pos</code> <code>Union[Point2, tuple[float, float]]</code> <p>Measure angle to this 2D point.</p> required <p>Returns:</p> Name Type Description <code>angle</code> <code>float</code> <p>Angle in radians.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_angle_to(\n    from_pos: Union[Point2, tuple[float, float]],\n    to_pos: Union[Point2, tuple[float, float]],\n) -&gt; float:\n    \"\"\"Angle from point to other point in radians\n\n    Args:\n        from_pos: First 2D point.\n        to_pos: Measure angle to this 2D point.\n\n    Returns:\n        angle: Angle in radians.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_distance_to","title":"<code>cy_distance_to(p1, p2)</code>","text":"<p>Check distance between two Point2 positions.</p> <p>Example: <pre><code>from cython_functions import cy_distance_to\n\ndist: float = cy_distance_to(\n    self.start_location, self.game_info.map_center\n)\n</code></pre> <pre><code>cy_distance_to(Point2, Point2)\n157 ns \u00b1 2.69 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\ncy_distance_to(unit1.position, unit2.position)\n219 ns \u00b1 10.5 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nPython alternative:\n\nPoint1.distance_to(Point2)\n386 ns \u00b1 2.71 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nunit1.distance_to(unit2)\n583 ns \u00b1 7.89 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>Union[Point2, tuple[float, float]]</code> <p>First point.</p> required <code>p2</code> <code>Union[Point2, tuple[float, float]]</code> <p>Measure to this point.</p> required <p>Returns:</p> Name Type Description <code>distance</code> <code>float</code> <p>Distance in tiles.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_distance_to(\n    p1: Union[Point2, tuple[float, float]], p2: Union[Point2, tuple[float, float]]\n) -&gt; float:\n    \"\"\"Check distance between two Point2 positions.\n\n    Example:\n    ```py\n    from cython_functions import cy_distance_to\n\n    dist: float = cy_distance_to(\n        self.start_location, self.game_info.map_center\n    )\n    ```\n    ```\n    cy_distance_to(Point2, Point2)\n    157 ns \u00b1 2.69 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\n    cy_distance_to(unit1.position, unit2.position)\n    219 ns \u00b1 10.5 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    Python alternative:\n\n    Point1.distance_to(Point2)\n    386 ns \u00b1 2.71 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    unit1.distance_to(unit2)\n    583 ns \u00b1 7.89 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n    ```\n\n    Args:\n        p1: First point.\n        p2: Measure to this point.\n\n    Returns:\n        distance: Distance in tiles.\n\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_distance_to_squared","title":"<code>cy_distance_to_squared(p1, p2)</code>","text":"<p>Similar to <code>cy_distance_to</code> but without a square root operation. Use this for ~1.3x speedup</p> <p>Example: <pre><code>from cython_functions import cy_distance_to_squared\n\ndist: float = cy_distance_to_squared(\n    self.start_location, self.game_info.map_center\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>Union[Point2, tuple[float, float]]</code> <p>First point.</p> required <code>p2</code> <code>Union[Point2, tuple[float, float]]</code> <p>Measure to this point.</p> required <p>Returns:</p> Name Type Description <code>distance</code> <code>float</code> <p>Distance in tiles, squared.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_distance_to_squared(\n    p1: Union[Point2, tuple[float, float]], p2: Union[Point2, tuple[float, float]]\n) -&gt; float:\n    \"\"\"Similar to `cy_distance_to` but without a square root operation.\n    Use this for ~1.3x speedup\n\n    Example:\n    ```python\n    from cython_functions import cy_distance_to_squared\n\n    dist: float = cy_distance_to_squared(\n        self.start_location, self.game_info.map_center\n    )\n    ```\n\n    Args:\n        p1: First point.\n        p2: Measure to this point.\n\n    Returns:\n        distance: Distance in tiles, squared.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_find_average_angle","title":"<code>cy_find_average_angle(start_point, reference_point, points)</code>","text":"<p>Find the average angle between the points and the reference point.</p> <p>Given a starting point, a reference point, and a list of points, find the average angle between the vectors from the starting point to the reference point and the starting point to the points.</p> <p>Example: <pre><code>from cython_extensions import cy_find_average_angle\n\nangle: float = cy_get_angle_between_points(\n    self.start_location,\n    self.game_info.map_center,\n    [w.position for w in self.workers]\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>start_point</code> <code>Union[Point2, tuple[float, float]]</code> <p>Origin for the vectors to the other given points.</p> required <code>reference_point</code> <code>Union[Point2, tuple[float, float]]</code> <p>Vector forming one leg of the angle.</p> required <code>points</code> <code>list[Point2]</code> <p>Points to calculate the angle between relative to the reference point.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Average angle in radians between the reference</p> <code>float</code> <p>point and the given points.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_find_average_angle(\n    start_point: Union[Point2, tuple[float, float]],\n    reference_point: Union[Point2, tuple[float, float]],\n    points: list[Point2],\n) -&gt; float:\n    \"\"\"Find the average angle between the points and the reference point.\n\n    Given a starting point, a reference point, and a list of points, find the average\n    angle between the vectors from the starting point to the reference point and the\n    starting point to the points.\n\n    Example:\n    ```py\n    from cython_extensions import cy_find_average_angle\n\n    angle: float = cy_get_angle_between_points(\n        self.start_location,\n        self.game_info.map_center,\n        [w.position for w in self.workers]\n    )\n    ```\n\n    Args:\n        start_point: Origin for the vectors to the other given points.\n        reference_point: Vector forming one leg of the angle.\n        points: Points to calculate the angle between relative\n            to the reference point.\n\n    Returns:\n        Average angle in radians between the reference\n        point and the given points.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_find_correct_line","title":"<code>cy_find_correct_line(points, base_location)</code>","text":"<p>Given a list of points and a center point, find if there's a line such that all other points are above or below the line. Returns the line in the form Ax + By + C = 0 and the point that was used.</p> <p>If no such line is found, it returns ((0, 0, 0), ). <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[Point2]</code> <p>Points that need to be on one side of the line.</p> required <code>base_location</code> <code>Union[Point2, tuple[float, float]]</code> <p>Starting point for the line.</p> required <p>Returns:</p> Type Description <code>tuple[float]</code> <p>First element is the coefficients of Ax + By + C = 0.</p> <code>tuple[float]</code> <p>Second element is the point used to form the line.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_find_correct_line(\n    points: list[Point2], base_location: Union[Point2, tuple[float, float]]\n) -&gt; tuple[tuple[float], tuple[float]]:\n    \"\"\"\n    Given a list of points and a center point, find if there's a line such that all\n    other points are above or below the line. Returns the line in the form\n    Ax + By + C = 0 and the point that was used.\n\n    If no such line is found, it returns ((0, 0, 0), &lt;last_point_checked&gt;).\n\n    Args:\n        points: Points that need to be on one side of the line.\n        base_location: Starting point for the line.\n\n    Returns:\n        First element is the coefficients of Ax + By + C = 0.\n        Second element is the point used to form the line.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_get_angle_between_points","title":"<code>cy_get_angle_between_points(point_a, point_b)</code>","text":"<p>Get the angle between two points as if they were vectors from the origin.</p> <p>Example: <pre><code>from cython_functions import cy_get_angle_between_points\n\nangle: float = cy_get_angle_between_points(\n    self.start_location, self.game_info.map_center\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>point_a</code> <code>Union[Point2, tuple[float, float]]</code> <p>First point.</p> required <code>point_b</code> <code>Union[Point2, tuple[float, float]]</code> <p>Measure to this point.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The angle between the two points.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_get_angle_between_points(\n    point_a: Union[Point2, tuple[float, float]],\n    point_b: Union[Point2, tuple[float, float]],\n) -&gt; float:\n    \"\"\"Get the angle between two points as if they were vectors from the origin.\n\n    Example:\n    ```py\n    from cython_functions import cy_get_angle_between_points\n\n    angle: float = cy_get_angle_between_points(\n        self.start_location, self.game_info.map_center\n    )\n    ```\n\n    Args:\n        point_a: First point.\n        point_b: Measure to this point.\n\n    Returns:\n        The angle between the two points.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_towards","title":"<code>cy_towards(start_pos, target_pos, distance)</code>","text":"<p>Get position from start_pos towards target_pos based on distance.</p> <p>Example: <pre><code>from cython_functions import cy_towards\n\nnew_pos: Tuple[float, float] = cy_towards(\n    self.start_location,\n    self.game_info.map_center,\n    12.0\n)\n</code></pre></p> <p>Note: For performance reasons this returns the point2 as a tuple, if a python-sc2 Point2 is required it's up to the user to convert it.</p> <p>Example: <pre><code>new_pos: Point2 = Point2(\n    cy_towards(\n        self.start_location, self.enemy_start_locations, 10.0\n    )\n)\n</code></pre></p> <p>Though for best performance it is recommended to simply work with the tuple if possible: <pre><code>new_pos: tuple[float, float] = cy_towards(\n    self.start_location, self.enemy_start_locations, 10.0\n)\n</code></pre></p> <pre><code>191 ns \u00b1 0.855 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\nPython-sc2's `start_pos.towards(target_pos, distance)` alternative:\n2.73 \u00b5s \u00b1 18.9 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>start_pos</code> <code>Point2</code> <p>Start from this 2D position.</p> required <code>target_pos</code> <code>Point2</code> <p>Go towards this 2D position.</p> required <code>distance</code> <code>float</code> <p>How far we go towards target_pos.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>The new position as a tuple of x and y coordinates.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_towards(\n    start_pos: Point2, target_pos: Point2, distance: float\n) -&gt; tuple[float, float]:\n    \"\"\"Get position from start_pos towards target_pos based on distance.\n\n    Example:\n    ```py\n    from cython_functions import cy_towards\n\n    new_pos: Tuple[float, float] = cy_towards(\n        self.start_location,\n        self.game_info.map_center,\n        12.0\n    )\n    ```\n\n    Note: For performance reasons this returns the point2 as a tuple, if a\n    python-sc2 Point2 is required it's up to the user to convert it.\n\n    Example:\n    ```py\n    new_pos: Point2 = Point2(\n        cy_towards(\n            self.start_location, self.enemy_start_locations, 10.0\n        )\n    )\n    ```\n\n    Though for best performance it is recommended to simply work with the tuple if possible:\n    ```py\n    new_pos: tuple[float, float] = cy_towards(\n        self.start_location, self.enemy_start_locations, 10.0\n    )\n    ```\n\n    ```\n    191 ns \u00b1 0.855 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000,000 loops each)\n\n    Python-sc2's `start_pos.towards(target_pos, distance)` alternative:\n    2.73 \u00b5s \u00b1 18.9 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n    ```\n\n\n    Args:\n        start_pos: Start from this 2D position.\n        target_pos: Go towards this 2D position.\n        distance: How far we go towards target_pos.\n\n    Returns:\n        The new position as a tuple of x and y coordinates.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.geometry.cy_translate_point_along_line","title":"<code>cy_translate_point_along_line(point, a_value, distance)</code>","text":"<p>Translates a point along a line defined by a slope value.</p> <p>This function moves a given point along a line in a direction determined by the slope <code>a_value</code>, by a specified <code>distance</code>. The new point after translation is returned.</p> <p>Parameters:</p> Name Type Description Default <code>point</code> <code>Union[Point2, tuple[float, float]]</code> <p>The point to be translated, given as either a <code>Point2</code></p> required <code>a_value</code> <code>float</code> <p>The slope of the line along which the point will be moved.</p> required <code>distance</code> <code>float</code> <p>The distance to move the point along the line.</p> required <p>Returns:</p> Type Description <code>float</code> <p>A tuple representing the new position of the point</p> <code>float</code> <p>after translation.</p> Source code in <code>cython_extensions/geometry.pyi</code> <pre><code>def cy_translate_point_along_line(\n    point: Union[Point2, tuple[float, float]], a_value: float, distance: float\n) -&gt; tuple[float, float]:\n    \"\"\"\n    Translates a point along a line defined by a slope value.\n\n    This function moves a given point along a line in a direction\n    determined by the slope `a_value`, by a specified `distance`.\n    The new point after translation is returned.\n\n    Args:\n        point: The point to be translated, given as either a `Point2`\n        object or a tuple of `(x, y)` coordinates.\n        a_value: The slope of the line along which the point will be moved.\n        distance: The distance to move the point along the line.\n\n    Returns:\n        A tuple representing the new position of the point\n        after translation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.map_analysis.cy_flood_fill_grid","title":"<code>cy_flood_fill_grid(start_point, terrain_grid, pathing_grid, max_distance, cutoff_points)</code>","text":"<p>Given a set of coordinates, draw a box that fits all the points.</p> <p>Example: <pre><code>from cython_extensions import cy_flood_fill_grid\n\nall_points = terrain_flood_fill(\n    start_point=self.start_location.rounded,\n    terrain_grid=self.game_info.terrain_height.data_numpy.T,\n    pathing_grid=self.game_info.pathing_grid.data_numpy.T,\n    max_distance=40,\n    choke_points={}\n)\n</code></pre></p>"},{"location":"index.html#cython_extensions.map_analysis.cy_flood_fill_grid--parameters","title":"Parameters","text":"<p>start_point : Start algorithm from here. terrain_grid : Numpy array containing heights for the map. pathing_grid : Numpy array containing pathing values for the map. max_distance : The maximum distance the flood fill should reach before halting. cutoff_points : Points which we don't want the algorithm to pass. Choke points are a good use case.</p>"},{"location":"index.html#cython_extensions.map_analysis.cy_flood_fill_grid--returns","title":"Returns","text":"<p>tuple of tuple of float :     A pair of coordinates that determine the box in the following format:     ((xmin, xmax), (ymin, ymax))</p> Source code in <code>cython_extensions/map_analysis.pyi</code> <pre><code>def cy_flood_fill_grid(\n    start_point: Union[Point2, tuple],\n    terrain_grid: np.ndarray,\n    pathing_grid: np.ndarray,\n    max_distance: int,\n    cutoff_points: set,\n) -&gt; set[tuple]:\n    \"\"\"Given a set of coordinates, draw a box that fits\n    all the points.\n\n    Example:\n    ```py\n    from cython_extensions import cy_flood_fill_grid\n\n    all_points = terrain_flood_fill(\n        start_point=self.start_location.rounded,\n        terrain_grid=self.game_info.terrain_height.data_numpy.T,\n        pathing_grid=self.game_info.pathing_grid.data_numpy.T,\n        max_distance=40,\n        choke_points={}\n    )\n\n    ```\n\n    Parameters\n    ----------\n    start_point : Start algorithm from here.\n    terrain_grid : Numpy array containing heights for the map.\n    pathing_grid : Numpy array containing pathing values for the map.\n    max_distance : The maximum distance the flood fill should reach before halting.\n    cutoff_points : Points which we don't want the algorithm to pass.\n    Choke points are a good use case.\n\n    Returns\n    -------\n    tuple of tuple of float :\n        A pair of coordinates that determine the box in the following format:\n        ((xmin, xmax), (ymin, ymax))\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.map_analysis.cy_get_bounding_box","title":"<code>cy_get_bounding_box(coordinates)</code>","text":"<p>Given a set of coordinates, draw a box that fits all the points.</p> <p>Example: <pre><code>from cython_extensions import cy_get_bounding_box\n\npoints: set[Point2] = {w.position for w in self.workers}\nraw_x_bounds, raw_y_bounds = cy_get_bounding_box(points)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>coordinates</code> <code>set[Point2]</code> <p>The points around which the bounding box should be drawn.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>A tuple containing two tuples:</p> <code>tuple[float, float]</code> <ul> <li>The first tuple represents the minimum and maximum x values</li> </ul> <code>tuple[tuple[float, float], tuple[float, float]]</code> <p>(xmin, xmax).</p> <code>tuple[tuple[float, float], tuple[float, float]]</code> <ul> <li>The second tuple represents the minimum and maximum y values</li> </ul> <code>tuple[tuple[float, float], tuple[float, float]]</code> <p>(ymin, ymax).</p> Source code in <code>cython_extensions/map_analysis.pyi</code> <pre><code>def cy_get_bounding_box(\n    coordinates: set[Point2],\n) -&gt; tuple[tuple[float, float], tuple[float, float]]:\n    \"\"\"Given a set of coordinates, draw a box that fits\n    all the points.\n\n    Example:\n    ```py\n    from cython_extensions import cy_get_bounding_box\n\n    points: set[Point2] = {w.position for w in self.workers}\n    raw_x_bounds, raw_y_bounds = cy_get_bounding_box(points)\n\n    ```\n\n    Args:\n        coordinates:\n            The points around which the bounding box should be drawn.\n\n    Returns:\n        A tuple containing two tuples:\n        - The first tuple represents the minimum and maximum x values\n        (xmin, xmax).\n        - The second tuple represents the minimum and maximum y values\n        (ymin, ymax).\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.numpy_helper.cy_all_points_below_max_value","title":"<code>cy_all_points_below_max_value(grid, value, points_to_check)</code>","text":"<p>Check points on grid, and return True if they are all below <code>value</code>.</p> <p>Example: <pre><code>from cython_extensions import cy_all_points_below_max_value\n\n# pretend grid has enemy influence added\ngrid = self.game_info.pathing_grid.data_numpy.T\nall_safe: bool = cy_all_points_below_max_value(\n    grid, 1.0, [self.start_location.rounded]\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The grid to check.</p> required <code>value</code> <code>float</code> <p>The max value.</p> required <code>points_to_check</code> <code>list[tuple[int, int]]</code> <p>List of points we are checking.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Are all points_to_check below value?</p> Source code in <code>cython_extensions/numpy_helper.pyi</code> <pre><code>def cy_all_points_below_max_value(\n    grid: np.ndarray, value: float, points_to_check: list[tuple[int, int]]\n) -&gt; bool:\n    \"\"\"Check points on grid, and return True if they are all below\n    `value`.\n\n    Example:\n    ```py\n    from cython_extensions import cy_all_points_below_max_value\n\n    # pretend grid has enemy influence added\n    grid = self.game_info.pathing_grid.data_numpy.T\n    all_safe: bool = cy_all_points_below_max_value(\n        grid, 1.0, [self.start_location.rounded]\n    )\n\n    ```\n\n    Parameters:\n        grid: The grid to check.\n        value: The max value.\n        points_to_check: List of points we are checking.\n\n    Returns:\n        Are all points_to_check below value?\n\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.numpy_helper.cy_all_points_have_value","title":"<code>cy_all_points_have_value(grid, value, points)</code>","text":"<p>Check points on grid, and return True if they are all equal <code>value</code>.</p> <p>Example: <pre><code>from cython_extensions import cy_all_points_have_value\n\n# pretend grid has enemy influence added\ngrid = self.game_info.pathing_grid.data_numpy.T\nall_safe: bool = cy_all_points_have_value(\n    grid, 1.0, [self.start_location.rounded]\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The grid to check.</p> required <code>value</code> <code>float</code> <p>The max value.</p> required <code>points</code> <code>list[tuple[int, int]]</code> <p>List of points we are checking.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Are all points equal value?</p> Source code in <code>cython_extensions/numpy_helper.pyi</code> <pre><code>def cy_all_points_have_value(\n    grid: np.ndarray, value: float, points: list[tuple[int, int]]\n) -&gt; bool:\n    \"\"\"Check points on grid, and return True if they are all equal\n    `value`.\n\n    Example:\n    ```py\n    from cython_extensions import cy_all_points_have_value\n\n    # pretend grid has enemy influence added\n    grid = self.game_info.pathing_grid.data_numpy.T\n    all_safe: bool = cy_all_points_have_value(\n        grid, 1.0, [self.start_location.rounded]\n    )\n\n    ```\n\n    Parameters:\n        grid: The grid to check.\n        value: The max value.\n        points: List of points we are checking.\n\n    Returns:\n        Are all points equal value?\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.numpy_helper.cy_last_index_with_value","title":"<code>cy_last_index_with_value(grid, value, points)</code>","text":"<p>Finds the last index with the matching value, stopping as soon as a value doesn't match. Returns -1 if points is empty or the first value doesn't match</p> <p>Example: <pre><code>from cython_extensions import cy_last_index_with_value\n\ngrid = self.game_info.pathing_grid.data_numpy.T\npoints: list[Point2] = [w.position.rounded for w in self.workers]\nlast_pathable_index = cy_last_index_with_value(grid, 1, points)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The grid to check <code>points</code> on.</p> required <code>value</code> <code>int</code> <p>The value we are looking for.</p> required <code>points</code> <code>list[tuple[int, int]]</code> <p>Points we want to check</p> required <p>Returns:</p> Type Description <code>int</code> <p>The last index in <code>points</code> that has <code>value</code></p> Source code in <code>cython_extensions/numpy_helper.pyi</code> <pre><code>def cy_last_index_with_value(\n    grid: np.ndarray, value: int, points: list[tuple[int, int]]\n) -&gt; int:\n    \"\"\"Finds the last index with the matching value, stopping as soon as a\n    value doesn't match.\n    Returns -1 if points is empty or the first value doesn't match\n\n    Example:\n    ```py\n    from cython_extensions import cy_last_index_with_value\n\n    grid = self.game_info.pathing_grid.data_numpy.T\n    points: list[Point2] = [w.position.rounded for w in self.workers]\n    last_pathable_index = cy_last_index_with_value(grid, 1, points)\n\n    ```\n\n    Parameters:\n        grid: The grid to check `points` on.\n        value: The value we are looking for.\n        points: Points we want to check\n\n    Returns:\n        The last index in `points` that has `value`\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.numpy_helper.cy_point_below_value","title":"<code>cy_point_below_value(grid, position, weight_safety_limit=1.0)</code>","text":"<p>Check a position on a 2D grid. Is it below <code>weight_safety_limit</code>? Useful for checking enemy influence on a position.</p> <p>Example: <pre><code>from cython_extensions import cy_point_below_value\n\n# pretend grid has enemy influence added\ngrid = self.game_info.pathing_grid.data_numpy.T\nsafe: bool = cy_point_below_value(grid, self.start_location)\n</code></pre></p> <pre><code>987 ns \u00b1 10.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\nPython alternative:\n4.66 \u00b5s \u00b1 64.8 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The grid to check.</p> required <code>position</code> <code>Point2 | tuple[float, float]</code> <p>2D coordinate to check on grid.</p> required <code>weight_safety_limit</code> <code>float</code> <p>(default = 1.0) We want to check if the point is less than or equal to this.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>bool</code> <p>The last index in <code>points</code> that has <code>value</code>.</p> Source code in <code>cython_extensions/numpy_helper.pyi</code> <pre><code>def cy_point_below_value(\n    grid: np.ndarray,\n    position: Point2 | tuple[float, float],\n    weight_safety_limit: float = 1.0,\n) -&gt; bool:\n    \"\"\"Check a position on a 2D grid.\n    Is it below `weight_safety_limit`?\n    Useful for checking enemy influence on a position.\n\n    Example:\n    ```py\n    from cython_extensions import cy_point_below_value\n\n    # pretend grid has enemy influence added\n    grid = self.game_info.pathing_grid.data_numpy.T\n    safe: bool = cy_point_below_value(grid, self.start_location)\n    ```\n\n    ```\n    987 ns \u00b1 10.1 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000,000 loops each)\n\n    Python alternative:\n    4.66 \u00b5s \u00b1 64.8 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n    ```\n\n    Parameters:\n        grid: The grid to check.\n        position: 2D coordinate to check on grid.\n        weight_safety_limit: (default = 1.0) We want to check\n            if the point is less than or equal to this.\n\n    Returns:\n        The last index in `points` that has `value`.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.numpy_helper.cy_points_with_value","title":"<code>cy_points_with_value(grid, value, points)</code>","text":"<p>Check points on grid, and return those that equal <code>value</code></p> <p>Example: <pre><code>from cython_extensions import cy_points_with_value\nimport numpy as np\n\n# pretend grid has enemy influence added\ngrid: np.ndarray = self.game_info.pathing_grid.data_numpy.T\nsafe: bool = cy_points_with_value(\n    grid, 1.0, [self.start_location.rounded]\n)\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>ndarray</code> <p>The grid to check.</p> required <code>value</code> <code>float</code> <p>2D coordinate to check on grid.</p> required <code>points</code> <code>list[tuple[int, int]]</code> <p>List of points we are checking.</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int]]</code> <p>All points that equal <code>value</code> on grid.</p> Source code in <code>cython_extensions/numpy_helper.pyi</code> <pre><code>def cy_points_with_value(\n    grid: np.ndarray, value: float, points: list[tuple[int, int]]\n) -&gt; list[tuple[int, int]]:\n    \"\"\"Check points on grid, and return those that equal `value`\n\n    Example:\n    ```py\n    from cython_extensions import cy_points_with_value\n    import numpy as np\n\n    # pretend grid has enemy influence added\n    grid: np.ndarray = self.game_info.pathing_grid.data_numpy.T\n    safe: bool = cy_points_with_value(\n        grid, 1.0, [self.start_location.rounded]\n    )\n\n    ```\n\n    Parameters:\n        grid: The grid to check.\n        value: 2D coordinate to check on grid.\n        points: List of points we are checking.\n\n    Returns:\n        All points that equal `value` on grid.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.placement_solver.cy_can_place_structure","title":"<code>cy_can_place_structure(building_origin, building_size, creep_grid, placement_grid, pathing_grid, avoid_creep=True, include_addon=False)</code>","text":"<p>Simulate whether a structure can be placed at <code>building_origin</code> Fast alternative to python-sc2 <code>can_place</code></p> <p>Example: <pre><code>from cython_extensions import cy_can_place_structure\n\ncan_place: bool = cy_can_place_structure(\n    (155, 45),\n    (3, 3),\n    self.ai.state.creep.data_numpy,\n    self.ai.game_info.placement_grid.data_numpy,\n    self.ai.game_info.pathing_grid.data_numpy,\n    avoid_creep=self.race != Race.Zerg,\n    include_addon=False,\n)\n</code></pre></p> <pre><code>1.21 \u00b5s \u00b1 891 ns per loop (mean \u00b1 std. dev. of 1000 runs, 10 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>building_origin</code> <code>tuple[int, int]</code> <p>The top left corner of the intended structure.</p> required <code>building_size</code> <code>tuple[int, int]</code> <p>For example: (3, 3) for barracks. (2, 2) for depot, (5, 5) for command center.</p> required <code>creep_grid</code> <code>ndarray</code> <p>Creep grid.</p> required <code>placement_grid</code> <code>ndarray</code> required <code>pathing_grid</code> <code>ndarray</code> required <code>avoid_creep</code> <code>bool</code> <p>Ensure this is False if checking Zerg structures.</p> <code>True</code> <code>include_addon</code> <code>bool</code> <p>Check if there is room for addon too.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>Can we place structure at building_origin?</p> Source code in <code>cython_extensions/placement_solver.pyi</code> <pre><code>def cy_can_place_structure(\n    building_origin: tuple[int, int],\n    building_size: tuple[int, int],\n    creep_grid: np.ndarray,\n    placement_grid: np.ndarray,\n    pathing_grid: np.ndarray,\n    avoid_creep: bool = True,\n    include_addon: bool = False,\n) -&gt; bool:\n    \"\"\"Simulate whether a structure can be placed at `building_origin`\n    Fast alternative to python-sc2 `can_place`\n\n    Example:\n    ```py\n    from cython_extensions import cy_can_place_structure\n\n    can_place: bool = cy_can_place_structure(\n        (155, 45),\n        (3, 3),\n        self.ai.state.creep.data_numpy,\n        self.ai.game_info.placement_grid.data_numpy,\n        self.ai.game_info.pathing_grid.data_numpy,\n        avoid_creep=self.race != Race.Zerg,\n        include_addon=False,\n    )\n    ```\n\n    ```\n    1.21 \u00b5s \u00b1 891 ns per loop (mean \u00b1 std. dev. of 1000 runs, 10 loops each)\n    ```\n\n    Parameters:\n        building_origin: The top left corner of the intended structure.\n        building_size: For example: (3, 3) for barracks.\n            (2, 2) for depot,\n            (5, 5) for command center.\n        creep_grid: Creep grid.\n        placement_grid:\n        pathing_grid:\n        avoid_creep: Ensure this is False if checking Zerg structures.\n        include_addon: Check if there is room for addon too.\n\n    Returns:\n        Can we place structure at building_origin?\n\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.placement_solver.cy_find_building_locations","title":"<code>cy_find_building_locations(kernel, x_stride, y_stride, x_bounds, y_bounds, creep_grid, placement_grid, pathing_grid, points_to_avoid_grid, building_width, building_height, avoid_creep=True)</code>","text":"<p>Use a convolution pass to find all possible building locations in an area Check <code>ares-sc2</code> for a full example of using this to calculate building formations.</p> <p>https://github.com/AresSC2/ares-sc2/blob/main/src/ares/managers/placement_manager.py</p> <p>Example: <pre><code>from cython_extensions import cy_find_building_locations\n\n# find 3x3 locations, making room for addons.\n# check out map_analysis.cy_get_bounding_box to calculate\n# raw_x_bounds and raw_x_bounds\nthree_by_three_positions = cy_find_building_locations(\n    kernel=np.ones((5, 3), dtype=np.uint8),\n    x_stride=5,\n    y_stride=3,\n    x_bounds=raw_x_bounds,\n    y_bounds=raw_y_bounds,\n    creep_grid=creep_grid,\n    placement_grid=placement_grid,\n    pathing_grid=pathing_grid,\n    points_to_avoid_grid=self.points_to_avoid_grid,\n    building_width=3,\n    building_height=3,\n    avoid_creep=True\n)\n</code></pre></p> <pre><code>64.8 \u00b5s \u00b1 4.05 \u00b5s per loop (mean \u00b1 std. dev. of 1000 runs, 10 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>kernel</code> <code>ndarray</code> <p>The size of the sliding window that scans this area.</p> required <code>x_stride</code> <code>int</code> <p>The x distance the kernel window moves each step.</p> required <code>y_stride</code> <code>int</code> <p>The y distance the kernel window moves downwards.</p> required <code>x_bounds</code> <code>tuple[int, int]</code> <p>The starting point of the algorithm.</p> required <code>y_bounds</code> <code>tuple[int, int]</code> <p>The end point of the algorithm.</p> required <code>creep_grid</code> <code>ndarray</code> required <code>placement_grid</code> <code>ndarray</code> required <code>pathing_grid</code> <code>ndarray</code> required <code>points_to_avoid_grid</code> <code>ndarray</code> <p>Grid containing <code>1</code>s where we shouldn't place anything.</p> required <code>building_width</code> <code>int</code> required <code>building_height</code> <code>int</code> required <code>avoid_creep</code> <code>bool</code> <p>Ensure this is False if checking Zerg structures.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[float, float]]</code> <p>Final list of positions that make up the building formation.</p> Source code in <code>cython_extensions/placement_solver.pyi</code> <pre><code>def cy_find_building_locations(\n    kernel: np.ndarray,\n    x_stride: int,\n    y_stride: int,\n    x_bounds: tuple[int, int],\n    y_bounds: tuple[int, int],\n    creep_grid: np.ndarray,\n    placement_grid: np.ndarray,\n    pathing_grid: np.ndarray,\n    points_to_avoid_grid: np.ndarray,\n    building_width: int,\n    building_height: int,\n    avoid_creep: bool = True,\n) -&gt; list[tuple[float, float]]:\n    \"\"\"Use a convolution pass to find all possible building locations in an area\n    Check `ares-sc2` for a full example of using this to calculate\n    building formations.\n\n    https://github.com/AresSC2/ares-sc2/blob/main/src/ares/managers/placement_manager.py\n\n    Example:\n    ```py\n    from cython_extensions import cy_find_building_locations\n\n    # find 3x3 locations, making room for addons.\n    # check out map_analysis.cy_get_bounding_box to calculate\n    # raw_x_bounds and raw_x_bounds\n    three_by_three_positions = cy_find_building_locations(\n        kernel=np.ones((5, 3), dtype=np.uint8),\n        x_stride=5,\n        y_stride=3,\n        x_bounds=raw_x_bounds,\n        y_bounds=raw_y_bounds,\n        creep_grid=creep_grid,\n        placement_grid=placement_grid,\n        pathing_grid=pathing_grid,\n        points_to_avoid_grid=self.points_to_avoid_grid,\n        building_width=3,\n        building_height=3,\n        avoid_creep=True\n    )\n\n    ```\n\n    ```\n    64.8 \u00b5s \u00b1 4.05 \u00b5s per loop (mean \u00b1 std. dev. of 1000 runs, 10 loops each)\n    ```\n\n    Parameters:\n        kernel: The size of the sliding window that scans this area.\n        x_stride: The x distance the kernel window moves each step.\n        y_stride: The y distance the kernel window moves downwards.\n        x_bounds: The starting point of the algorithm.\n        y_bounds: The end point of the algorithm.\n        creep_grid:\n        placement_grid:\n        pathing_grid:\n        points_to_avoid_grid: Grid containing `1`s where we shouldn't\n            place anything.\n        building_width:\n        building_height:\n        avoid_creep: Ensure this is False if checking Zerg structures.\n\n    Returns:\n        Final list of positions that make up the building formation.\n\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.units_utils.cy_center","title":"<code>cy_center(units)</code>","text":"<p>Given some units, find the center point.</p> <p>Example: <pre><code>from ares.cython_functions.units_utils import cy_center\n\ncentroid: Tuple[float, float] = cy_center(self.workers)\n\n# centroid_point2 = Point2(centroid)\n</code></pre></p> <pre><code>54.2 \u00b5s \u00b1 137 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n`python-sc2`'s `units.center` alternative:\n107 \u00b5s \u00b1 255 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>Union[Units, list[Unit]]</code> <p>Units we want to check</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Centroid of all units positions</p> Source code in <code>cython_extensions/units_utils.pyi</code> <pre><code>def cy_center(units: Union[Units, list[Unit]]) -&gt; tuple[float, float]:\n    \"\"\"Given some units, find the center point.\n\n\n    Example:\n    ```py\n    from ares.cython_functions.units_utils import cy_center\n\n    centroid: Tuple[float, float] = cy_center(self.workers)\n\n    # centroid_point2 = Point2(centroid)\n    ```\n\n    ```\n    54.2 \u00b5s \u00b1 137 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n    `python-sc2`'s `units.center` alternative:\n    107 \u00b5s \u00b1 255 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n    ```\n\n    Parameters:\n        units: Units we want to check\n\n    Returns:\n        Centroid of all units positions\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.units_utils.cy_closest_to","title":"<code>cy_closest_to(position, units)</code>","text":"<p>Iterate through <code>units</code> to find closest to <code>position</code>.</p> <p>Example: <pre><code>from cython_functions import cy_closest_to\nfrom sc2.unit import Unit\n\nclosest_unit: Unit = cy_closest_to(self.start_location, self.workers)\n</code></pre></p> <pre><code>14.3 \u00b5s \u00b1 135 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n\npython-sc2's `units.closest_to()` alternative:\n98.9 \u00b5s \u00b1 240 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\nIf using python-sc2's `units.closest_to(Point2):\n200 \u00b5s \u00b1 1.02 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Union[Point2, tuple[float, float]]</code> <p>Position to measure distance from.</p> required <code>units</code> <code>Union[Units, list[Unit]]</code> <p>Collection of units we want to check.</p> required <p>Returns:</p> Type Description <code>Unit</code> <p>Unit closest to <code>position</code>.</p> Source code in <code>cython_extensions/units_utils.pyi</code> <pre><code>def cy_closest_to(\n    position: Union[Point2, tuple[float, float]], units: Union[Units, list[Unit]]\n) -&gt; Unit:\n    \"\"\"Iterate through `units` to find closest to `position`.\n\n    Example:\n    ```py\n    from cython_functions import cy_closest_to\n    from sc2.unit import Unit\n\n    closest_unit: Unit = cy_closest_to(self.start_location, self.workers)\n    ```\n\n    ```\n    14.3 \u00b5s \u00b1 135 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n\n    python-sc2's `units.closest_to()` alternative:\n    98.9 \u00b5s \u00b1 240 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n    If using python-sc2's `units.closest_to(Point2):\n    200 \u00b5s \u00b1 1.02 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n    ```\n\n    Parameters:\n        position: Position to measure distance from.\n        units: Collection of units we want to check.\n\n    Returns:\n        Unit closest to `position`.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.units_utils.cy_find_units_center_mass","title":"<code>cy_find_units_center_mass(units, distance)</code>","text":"<p>Given some units, find the center mass</p> <p>Example: <pre><code>from cython_functions import cy_find_units_center_mass\nfrom sc2.position import Point2\n\ncenter_mass: Point2\nnum_units: int\ncenter_mass, num_units = cy_find_units_center_mass(self.units, 10.0)\n</code></pre></p> <pre><code>47.8 ms \u00b1 674 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\npython alternative:\n322 ms \u00b1 5.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>Union[Units, list[Unit]]</code> <p>Collection of units we want to check.</p> required <code>distance</code> <code>float</code> <p>The distance to check from the center mass.</p> required <p>Returns:</p> Type Description <code>tuple[tuple[float, float], int]</code> <p>The center mass, and how many units are within <code>distance</code> of the center mass.</p> Source code in <code>cython_extensions/units_utils.pyi</code> <pre><code>def cy_find_units_center_mass(\n    units: Union[Units, list[Unit]], distance: float\n) -&gt; tuple[tuple[float, float], int]:\n    \"\"\"Given some units, find the center mass\n\n    Example:\n    ```py\n    from cython_functions import cy_find_units_center_mass\n    from sc2.position import Point2\n\n    center_mass: Point2\n    num_units: int\n    center_mass, num_units = cy_find_units_center_mass(self.units, 10.0)\n    ```\n\n    ```\n    47.8 ms \u00b1 674 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\n    python alternative:\n    322 ms \u00b1 5.2 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n    ```\n\n    Parameters:\n        units: Collection of units we want to check.\n        distance: The distance to check from the center mass.\n\n    Returns:\n        The center mass, and how many units are within `distance` of the center mass.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.units_utils.cy_in_attack_range","title":"<code>cy_in_attack_range(unit, units, bonus_distance=0.0)</code>","text":"<p>Find all units that unit can shoot at.</p> <p>Doesn't check if the unit weapon is ready. See: <code>cython_functions.attack_ready</code></p> <p>Example: <pre><code>from cython_functions import cy_in_attack_range\nfrom sc2.unit import Unit\n\nin_attack_range: list[Unit] = cy_in_attack_range(self.workers[0], self.enemy_units)\n</code></pre></p> <pre><code>7.28 \u00b5s \u00b1 26.3 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n\npython-sc2's `units.in_attack_range_of(unit)` alternative:\n30.4 \u00b5s \u00b1 271 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>unit</code> <code>Unit</code> <p>The unit to measure distance from.</p> required <code>units</code> <code>Union[Units, list[Unit]]</code> <p>Collection of units we want to check.</p> required <code>bonus_distance</code> <code>float</code> <p>Additional distance to consider.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>list[Unit]</code> <p>Units that are in attack range of <code>unit</code>.</p> Source code in <code>cython_extensions/units_utils.pyi</code> <pre><code>def cy_in_attack_range(\n    unit: Unit, units: Union[Units, list[Unit]], bonus_distance: float = 0.0\n) -&gt; list[Unit]:\n    \"\"\"Find all units that unit can shoot at.\n\n    Doesn't check if the unit weapon is ready. See:\n    `cython_functions.attack_ready`\n\n    Example:\n    ```py\n    from cython_functions import cy_in_attack_range\n    from sc2.unit import Unit\n\n    in_attack_range: list[Unit] = cy_in_attack_range(self.workers[0], self.enemy_units)\n    ```\n\n    ```\n    7.28 \u00b5s \u00b1 26.3 ns per loop (mean \u00b1 std. dev. of 7 runs, 100,000 loops each)\n\n    python-sc2's `units.in_attack_range_of(unit)` alternative:\n    30.4 \u00b5s \u00b1 271 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n    ```\n\n    Parameters:\n        unit: The unit to measure distance from.\n        units: Collection of units we want to check.\n        bonus_distance: Additional distance to consider.\n\n    Returns:\n        Units that are in attack range of `unit`.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"index.html#cython_extensions.units_utils.cy_sorted_by_distance_to","title":"<code>cy_sorted_by_distance_to(units, position, reverse=False)</code>","text":"<p>Sort units by distance to <code>position</code></p> <p>Example: <pre><code>from cython_functions import cy_sorted_by_distance_to\nfrom sc2.unit import Unit\n\nsorted_by_distance: list[Unit] = cy_sorted_by_distance_to(\n    self.workers, self.start_location\n)\n</code></pre></p> <pre><code>33.7 \u00b5s \u00b1 190 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\npython-sc2's `units.sorted_by_distance_to(position)` alternative:\n246 \u00b5s \u00b1 830 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>units</code> <code>Union[Units, list[Unit]]</code> <p>Units we want to sort.</p> required <code>position</code> <code>Point2</code> <p>Sort by distance to this position.</p> required <code>reverse</code> <code>bool</code> <p>Not currently used.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[Unit]</code> <p>Units sorted by distance to position.</p> Source code in <code>cython_extensions/units_utils.pyi</code> <pre><code>def cy_sorted_by_distance_to(\n    units: Union[Units, list[Unit]], position: Point2, reverse: bool = False\n) -&gt; list[Unit]:\n    \"\"\"Sort units by distance to `position`\n\n    Example:\n    ```py\n    from cython_functions import cy_sorted_by_distance_to\n    from sc2.unit import Unit\n\n    sorted_by_distance: list[Unit] = cy_sorted_by_distance_to(\n        self.workers, self.start_location\n    )\n    ```\n\n    ```\n    33.7 \u00b5s \u00b1 190 ns per loop (mean \u00b1 std. dev. of 7 runs, 10,000 loops each)\n\n    python-sc2's `units.sorted_by_distance_to(position)` alternative:\n    246 \u00b5s \u00b1 830 ns per loop (mean \u00b1 std. dev. of 7 runs, 1,000 loops each)\n    ```\n\n    Parameters:\n        units: Units we want to sort.\n        position: Sort by distance to this position.\n        reverse: Not currently used.\n\n    Returns:\n        Units sorted by distance to position.\n\n    \"\"\"\n    ...\n</code></pre>"}]}